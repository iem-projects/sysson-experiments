# IfLag

The first problem is that we cannot use an 'always high' signal
for the branch selection because since the child is paused, it
will only ever see that high value and thus not retrigger. That's
why with `If` we use a single impulse now. With `IfLag` we know
(or the designer is responsible and knows) that there is going to
be time to receive a gate change from high to low before the node
actually pauses. We have thus two possibilities:

- go back from trigger (`Delay1(x) sig_!= x`) to a gate (`x sig_== y`).
- send a second trigger

The second case is probably better because it means we can move
between `If` and `IfLag` without too much thought on the behavioural
change of `ThisBranch`. Plus the branch can now easily use a
`ToggleFF` to get a gate signal. And the second trigger is already
implemented because we use just one bus for all children.
The disadvantage are are

- the meaning of `ThisBranch` is conjured
- the branch needs extra effort to distinguish the two triggers

Taking that into account, it may well be better to send the branch-id
again and on the receiving end do the `sig_==` comparison. Wherever
`ThisBranch` was used as a trigger, it should still work with the
opening of the gate.

## Transition

The more difficult question is the blocking of changing signals
during release, and the delay of the `Pause` actions.

The phase diagram is like this:

    branch-idx: 00000000010201111111111110212000000000000000
                         |               |
                         +--change issued, gate closes
                         |  hold dur = 4 |
    gate:       11111111100001111111111110000111111111111111 
    
    held-idx:   00000000011111111111111110000000000000000000
    
    pause 0:    00000000000001111111111111111000000000000000
    
    pause 1:    11111111111110000000000000000111111111111111
                                             *
    held seen 0:1111111110000                111111111111111
    
    held seen 1:             1111111111110000
    
The question is for child 0, if it properly sees a trigger at
point `*` (the second time it is resumed)? It would appear so
because any previous UGen state had been left at zero before.

This works as long as `lag-dur >= ControlDur`. We can clip the
value to ensure this. If the lag-time is given as a `GE` argument,
we also need to freeze that during hold? Since the `held-idx` is
not a binary signal now but a bit-field, we cannot use `TDelay`.
We will need to use `DelayN`? This was init-time maximum delay
parameter, so anyway we should restrict the lag time parameter to
scalar rate (e.g. feeding through `DC.kr`).

## Algorithm

- We create common basis of `If` and `IfLag`, with a flag for lag use.
We change between trigger and gate signal in condition-out and
condition-in (do we still have `thisBranch` code or are we just
looking for the `Link`?)
- We fix the lag time at scalar rate, clipped to be at least of
`ControlDur` duration.
- We use `Latch` to sample and hold the branch index. The trigger
is a `Trig1` of the `Delay1(x) sig_!= x` signal, with the trigger
duration set to the lag time.


    val condAcc: GE = ???
    val condChange = Delay1.kr(condAcc) sig_!= condAcc
    val condChHold = Trig1.kr(condChange, lagDur)
    val heldAcc = Latch.kr(condAcc, condChHold)
    val heldDly = DelayN.kr(heldAcc, lagDur)
    
    def pause(branchIdx: Int) = {
      val heldMask = heldDly & ((1 << (branchIdx + 1)) - 1)
      val heldEq = heldMask sig_== (1 << branchIdx)
      Pause.kr(gate = heldEq, node = nodeCtl.ir)
    }
    
Looking at the current implementation, that means we should not
work with incremental `condAcc` values, but completely calculate
the entire `condAcc` first. This requires an additional `bitAnd`
operation (for the first branch),
however it saves us from needing more than one `DelayN`.

Then the last problem to solve is the initial state. The `DelayN` will
be empty, i.e. zero, at the beginning.